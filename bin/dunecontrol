#!/bin/bash

set -e

###############################################
###
### check for environment variables
###

if test -z $MAKE; then
  MAKE=make
fi

###############################################
###
### read lib
###

canonicalname(){
  if test $# -ne 1; then
     echo Usage: canonicalname path > /dev/stderr
     return 1
  fi
  name="$1"
  while test -L "$name"; do
    if ! test -e "$name"; then
      echo $name: file not found > /dev/stderr
      return 1
    fi
    if newname="`readlink $name`"; then
      name="$newname"
    else
      echo "$(dirname $name)/$(basename $name)"
    fi
  done
  echo $name
}

canonicalpath(){
  if test $# -ne 1; then
     echo Usage: canonicalpath path > /dev/stderr
     return 1
  fi
  (cd $(dirname $(canonicalname $1)) && pwd)
}

if test "x$1" = "x--debug"; then
  DEBUG=yes
fi

if test "x$DEBUG" = "xyes"; then
  set -x
  set -v
fi

export COMMAND_DIR="`canonicalpath $0`"

# Read the modules find part
. "$COMMAND_DIR/dunemodules.inc"

# create PKG_CONFIG_PATH for installed dune modules
export PKG_CONFIG_PATH="$PKG_CONFIG_PATH:`canonicalpath $0`/../lib/pkgconfig"

###############################################

#
# for each module load the $CONTROL script part and run $command
#
# parameters:
# $1 command to execute
#
build_modules() {
  command="$1"
  load_opts $command
  local runcommand=run_$command
  modules="$MODULES"
  if test x"$ONLY" != x; then
	modules="$ONLY"
  fi  
  for module in $modules; do
    local path=$(eval "echo \$PATH_${module}")
    eval echo "--- calling $command for \$NAME_${module} ---"
    if ! (
      set -e
      cd "$path"
      eval_control $runcommand $path/$CONTROL
    ); then eval echo "--- Failed to build \$NAME_${module} ---"; exit 1; fi
    eval echo "--- \$NAME_${module} done ---"
  done
}

#
# load command options from an opts file
# the name of the opts file is stored in the global variable $DUNE_OPTS_FILE
#
# parameters:
# $1 command
#
load_opts() {
  local command=$1
  local COMMAND=$(echo $command | tr '[:lower:]' '[:upper:]')
  if test "x$DUNE_OPTS_FILE" != "x"; then
    echo "----- loading default flags \$${COMMAND}_FLAGS from $DUNE_OPTS_FILE -----"
    CMD_PARAMS="$(. $DUNE_OPTS_FILE; eval echo \$${COMMAND}_FLAGS)"
  else
    CMD_PARAMS="$(eval echo \$${COMMAND}_FLAGS)"
  fi
}

###############################################
###
### Commands
###

# check wheteher the parameter is valid command or not
is_command() {
eval '
case "$1" in
  '$(echo $COMMANDS | sed -e 's/ / | /g')')
    return 0
    ;;
  *)
    return 1
    ;;
esac'
}

# list of all dunecontrol commands
COMMANDS="update autogen configure make all exec status svn"

# help string for the commands
update_HELP="updated all modules from the repository"
autogen_HELP="run the autogen.sh script for each module"
configure_HELP="run configure for each module"
       # "NOTE: the --with-dune* parameters will be generated by dunecontrol"
make_HELP="run make for each module"
all_HELP="\trun 'autogen', 'configure' and 'make' command for each module"
       # "NOTE: run all for an initial setup"
exec_HELP="execute an arbitrary command in each module directory"
status_HELP="show vc status for all modules"
svn_HELP="\trun svn command for each svn managed module"

#
# setup command proxies
# call will be forwarded to run_default_$command
#

for command in $COMMANDS; do
  eval "run_$command () { run_default_$command; }"
done

#
# default implementations for commands... 
# these can be overwritten in the $CONTROL files
#

run_default_exec () { bash -c "eval $CMD_PARAMS"; }

run_default_status () {
  local verbose=0
  local update=""
  for i in $CMD_PARAMS; do
    if eval test "x$i" = "x-v"; then verbose=1; fi
    if eval test "x$i" = "x-vv"; then verbose=2; fi
    if eval test "x$i" = "x-u"; then update="-u"; fi
  done
  # is out output connected to a tty?
  if test -t 1; then
    blue="\e[1m\e[34m"
    green="\e[1m\e[32m"
    red="\e[1m\e[31m"
    reset="\e[0m\e[37m"
  fi

  if test $verbose -eq 1; then
    svn status $update | grep -E "^M|^A|^D|^C|^U"
  elif test $verbose -eq 2; then
    svn status $update
  fi

  name="$(eval echo \$NAME_$module)"
  changed=$(svn status | grep -E "^M|^A|^D" | wc -l)
  collisions=$(svn status | grep -E "^C"| wc -l)
  pending=$(svn status $update | grep -E "^...... \* " | wc -l)

  color=$green
  text="no changes"
  if [ $changed -eq 0 ]; then
	true
  elif [ $changed -eq 1 ]; then
	color=$blue;
    text="1 change"
  else
	color=$blue;
    text="$changed changes"
  fi
  if [ $pending -eq 0 ]; then
	true
  elif [ $pending -eq 1 ]; then
	color=$blue;
    text="$text, 1 update pending"
  else
	color=$blue;
    text="$text, $pending updates pending"
  fi
  if [ $collisions -eq 0 ]; then
	true
  elif [ $collisions -eq 1 ]; then
	color=$red
    text="$text, 1 collision"
  else
	color=$red
    text="$text, $count collisions"
  fi
  echo -e "$color[$text]$reset $name"
}

run_default_update () {
  if test -d .svn; then
    svn update
    return
  fi
  if test -d CVS; then
    cvs update -dP
    return
  fi
  echo "WARNING: $module is not under a known version control system."
  echo "         We support svn and cvs."
}

run_default_autogen () {
  PARAMS="$CMD_PARAMS"
  local M4_PATH=""
  if test -x autogen.sh; then
    for m in $FOUND_MODULES; do
      path=$(eval "echo \$PATH_$m")
      if test -d $path/m4; then
        M4_PATH="$path $M4_PATH"
      fi
    done
#    eval ./autogen.sh "$M4_PATH" "$PARAMS" || exit 1
    eval "$COMMAND_DIR/dune-autogen" "$M4_PATH" "$PARAMS" || exit 1
  fi
}

run_default_configure () {
  PARAMS="$CMD_PARAMS"
  if test -x configure; then
    if test "x$HAVE_dune_common" = "xyes"; then
      PARAMS="$PARAMS \"--with-dune-common=$PATH_dune_common\""
    fi
    if test "x$HAVE_dune_grid" = "xyes"; then
      PARAMS="$PARAMS \"--with-dune-grid=$PATH_dune_grid\""
    fi
    if test "x$HAVE_dune_istl" = "xyes"; then
      PARAMS="$PARAMS \"--with-dune-istl=$PATH_dune_istl\""
    fi
    if test "x$HAVE_dune_disc" = "xyes"; then
      PARAMS="$PARAMS \"--with-dune-disc=$PATH_dune_disc\""
    fi
    if test "x$HAVE_dune_fem" = "xyes"; then
      PARAMS="$PARAMS \"--with-dune-fem=$PATH_dune_fem\""
    fi
    if test "x$HAVE_dune_subgrid" = "xyes"; then
      PARAMS="$PARAMS \"--with-dune-subgrid=$PATH_dune_subgrid\""
    fi
    if test "x$HAVE_duneweb" = "xyes"; then
      PARAMS="$PARAMS \"--with-duneweb=$PATH_duneweb\""
    fi
    echo ./configure "$PARAMS"
    eval ./configure "$PARAMS" || exit 1
  else
    if test -f configure.in || test -f configure.ac; then
      echo "ERROR: configure.[in|ac] found, but configure missing" > /dev/stderr
      echo "did you forget to run autoconf?" > /dev/stderr
      exit 1
    fi
  fi
}

run_default_make () {
  PARAMS="$CMD_PARAMS"
  echo make "$PARAMS"
  eval $MAKE "$PARAMS"
}

run_default_all () {
  load_opts autogen
  run_autogen
  load_opts configure
  run_configure
  load_opts make
  run_make
}

run_default_svn () {
  if test -d .svn; then
	PARAMS="$CMD_PARAMS"
	eval svn "$PARAMS"
  fi
}

###############################################
###
### main
###

onfailure() {
  echo "Execution of $(basename $0) terminated due to errors!" > /dev/stderr
  exit 1
}

usage () {
  (
    echo "Usage: $(basename $0) [OPTIONS] COMMAND [COMMAND-OPTIONS]"
    echo ""
    echo "Execute COMMAND for all Dune modules found. All entries in the"
    echo "DUNE_CONTROL_PATH variable are scanned recursively for Dune modules."
	echo "If DUNE_CONTROL_PATH is empty, the current directory is scanned."
    echo "Dependencies are controlled by the $CONTROL files."
    echo ""
    echo "Options:"
    echo "  -h, --help         show this help"
    echo "      --debug        enable debug output of this script"
    echo "      --module=mod   only apply the actions on module mod"
    echo "                     and all modules it depends on"
    echo "      --only=mod     only apply the actions on module mod"
    echo "                     and not the modules it depends on"
    echo "      --opts=FILE    load default options from FILE"
    echo "                     (see dune-common/doc/example.opts)"
    echo "      --[COMMAND]-opts=opts   set options for COMMAND"
    echo "                     (this is mainly useful for the all COMMAND)"
    echo "Commands:"
    printf "  \`help'\tguess what :-)\n"
    printf "  \`print'\tprint the list of modules sorted after their dependencies\n"
    for i in $COMMANDS; do
      printf "  \`$i'\t$(eval echo \$${i}_HELP)\n"
    done
    printf "  \`export'\trun eval \`dunecontrol export\` to save the list of\n"
    printf "  \t\tdune.module files to the DUNE_CONTROL_PATH variable\n"
    echo
  )  > /dev/stderr
}

# create the module list
create_module_list() {
  find_modules_in_path
  if test "x$SEARCH_MODULES" != "x"; then
	sort_modules $SEARCH_MODULES
  else
	sort_modules $MODULES
  fi
  if test "x$ONLY" != x; then
    export MODULES="$ONLY"
  fi
}

# print the module list
print_module_list() {
  DELIM=$1
  shift
  while test -n "$2"; do
    echo -n "$(eval echo \$NAME_$1)$DELIM"
    shift
  done
  echo -n "$(eval echo \$NAME_$1)"
}

if test "x$1" = "x"; then
  usage
  exit 1
fi

trap onfailure EXIT

# clear command opts
for i in $COMMANDS; do
  COMMAND=$(echo $i | tr '[:lower:]' '[:upper:]')
  export ${COMMAND}_FLAGS=""
done

# clear variables
export SEARCH_MODULES=""
export MODULES=""
export ONLY=""

# parse commandline parameters
while test $# -gt 0; do
    # get option
    option=$1
    shift

    # get args
    set +e
    # stolen from configure...
    # when no option is set, this returns an error code
    arg=`expr "x$option" : 'x[^=]*=\(.*\)'`
    set -e

    # switch
    case "$option" in
    --opts=*)
      if test "x$arg" = "x"; then
        usage
        echo "ERROR: Parameter for --opts is missing"  > /dev/stderr
        echo  > /dev/stderr
        exit 1;
      fi
      DUNE_OPTS_FILE=$(canonicalpath $arg)/$(basename $arg)
      if ! test -r "$DUNE_OPTS_FILE"; then
        usage
        echo "ERROR: could not read opts file \"$DUNE_OPTS_FILE\""  > /dev/stderr
        echo  > /dev/stderr
        exit 1;
      fi
    ;;
	--*-opts=*)
      optcmd=`expr "x$option=" : 'x--\([^-]*\)-opts=.*'`
      if is_command $optcmd; then
        COMMAND=$(echo $optcmd | tr '[:lower:]' '[:upper:]')
        export ${COMMAND}_FLAGS="$arg"
      else
        usage
        echo "ERROR: unknown option \"$option\""  > /dev/stderr
        exit 1
      fi
    ;;
    -h|--help) 
      command=help
      break
    ;;
    -p|--print) 
      command=print
      break
    ;;
    --module=*)
      if test "x$arg" = "x"; then
        usage
        echo "ERROR: Parameter for --module is missing"  > /dev/stderr
        echo  > /dev/stderr
        exit 1;
      fi
	  for a in `echo $arg | tr ',' ' '`; do
        export NAME_`fix_variable_name $arg`="$a"
        fix_and_assign MODULE "$a"
        export SEARCH_MODULES="$SEARCH_MODULES $MODULE"
      done
    ;;
    --only=*)
      if test "x$arg" = "x"; then
        usage
        echo "ERROR: Parameter for --only is missing"  > /dev/stderr
        echo  > /dev/stderr
        exit 1;
      fi
	  for a in `echo $arg | tr ',' ' '`; do
        export NAME_`fix_variable_name $arg`="$a"
        fix_and_assign MODULE "$a"
        export SEARCH_MODULES="$SEARCH_MODULES $MODULE"
        export ONLY="$ONLY $MODULE"
      done
    ;;
    --debug) true ;;
    *)
      command=$option
      break
    ;;
    esac
done

while test $# -gt 0; do
  COMMAND=$(echo $command | tr '[:lower:]' '[:upper:]')
  # setup paramter list
  CMD_PARAMS="$CMD_PARAMS \"$1\""
  export ${COMMAND}_FLAGS="$CMD_PARAMS"
  shift
  # disable usage of opts file
  if test "x$DUNE_OPTS_FILE" != "x"; then
    echo "WARNING: commandline parameters will overwrite setting in opts file \"$DUNE_OPTS_FILE\""
  fi 
  DUNE_OPTS_FILE=""
done

# We need to run this via eval in order construct the case for the commands
case "$command" in
  print)
    create_module_list
    eval "print_module_list ' ' $MODULES"
    echo > /dev/stderr
    ;;
  m4depends)
    find_modules_in_path
    if test "x$SEARCH_MODULES" != "x"; then
	  MODULES=$SEARCH_MODULES
    fi
    if test "x$ONLY" != x; then
	  MODULES=$ONLY
    fi
	sort_dependecies $MODULES
    eval "print_module_list ',' $MODULES"
    ;;
  export)
    create_module_list
    DUNE_CONTROL_PATH=""
    for mod in $MODULES; do
      if test x != x$DUNE_CONTROL_PATH; then
        export DUNE_CONTROL_PATH="$DUNE_CONTROL_PATH:$(eval echo \$PATH_$mod/dune.module)"
      else
        export DUNE_CONTROL_PATH="$(eval echo \$PATH_$mod/dune.module)"
      fi
    done
    echo export DUNE_CONTROL_PATH=$DUNE_CONTROL_PATH
    ;;
  unexport)
	echo export DUNE_CONTROL_PATH=""
    ;;
  help)
    usage
    ;;
  *)
    if is_command $command; then
      create_module_list
      for mod in $MODULES; do
          NAMES="$NAMES$(eval echo \$NAME_$mod) "
      done
      echo "--- going to build $NAMES ---"
        build_modules $command
      echo "--- done ---"
	else
      usage
      echo "ERROR: unknown command \"$command\""  > /dev/stderr
      exit 1
    fi
    ;;
esac

trap - EXIT
